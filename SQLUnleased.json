[{"Qno":1,"Question":"Fibonacci numbers are a sequence of numbers starting with 0 and 1, and then each subsequent number is the sum of the previous two:<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...<br>Or expressed as the formula: Fn = Fn-1 + Fn-2<br>Which of the choices contain a query that selects the first 10 Fibonacci numbers, thus returning this output:<br><img src='images\\q1.png' /><br><b>Choose 1</b>","Option1":"WITH fib (idx, fib) AS(<br>SELECT 1 idx , 0 fib FROM dual UNION ALL SELECT f1.idx + 1 idx ,<br>CASE f1.idx WHEN 1 THEN 1 ELSE <br>( SELECT SUM(fib) FROM fib fprev WHERE fprev.idx BETWEEN f1.idx-1 AND f1.idx)<br>END fib<br>FROM fib f1<br>WHERE f1.idx < 10) SELECT FIB FROM FIB ORDER BY IDX;","Option2":"SELECT fib FROM(<br>SELECT level idx ,<br>CASE level WHEN 1 THEN 0<br>WHEN 2 THEN 1<br>ELSE prior fib + prior prevfib<br>END fib ,<br>CASE level<br>WHEN 1 THEN NULL<br>WHEN 2 THEN 0<br>ELSE prior fib END prevfib<br>FROM dual CONNECT BY level <= 10 )<br>ORDER BY IDX;","Option3":"SELECT fib<br>FROM dual model dimension BY (1 AS idx) measures (0 AS fib) rules upsert ALL ( fib[FOR idx<br>FROM 2 TO 10 increment 1] = fib[cv()-1] + NVL(fib[cv()-2],1) )<br>ORDER BY idx;","Option4":"SELECT fib FROM dual model dimension BY (1 AS idx) measures (0 AS fib) rules<br>UPDATE ( fib[FOR idx<br>FROM 2 TO 10 increment 1] = fib[cv()-1] + NVL(fib[cv()-2],1) )<br>ORDER BY idx;","Option5":"All the above","Answer":"<b>C)</b><br>A) Wrong. Fails with ORA-32042 because you cannot do a nested subquery on a recursive subquery</br>B)Wrong. Fails with ORA-00904 because connect by syntax does not allow use of calculated column aliases with prior operator.</br><b>C) Correct</b>. This time we do not iterate, but specify cell indexes with a FOR clause. UPSERT ALL makes it create the new cells.</br>D) Wrong. The UPDATE clause makes it so it can not create new cells, only update the one original cell fib[1]."},
{"Qno":2,"Question":"CONTACT Table has the data shown as shown<br><img src='images\\q2.png'/><br>Which of the following sql queries will yield the result shown below?<br><img src='images\\q2a.png'/><br><b>Choose 1</b> ","Option1":"SELECT person_key ,<br>MAX(DECODE(contact_type_code, 'LANDLINE', contact_detail)) landline ,<br>MAX(DECODE(contact_type_code, 'MOBILE', contact_detail)) mobile ,<br>MAX(DECODE(contact_type_code, 'WEBSITE', contact_detail)) website<br>FROM contact WHERE priority = 1;","Option2":"SELECT * FROM( <br> SELECT person_key ,contact_type_code ,contact_detail<br>FROM contact WHERE priority = 1) <br>PIVOT( MAX(contact_detail) FOR (contact_type_code) IN ('LANDLINE','MOBILE','WEBSITE') );","Option3":"SELECT * FROM(<br>SELECT person_key ,contact_type_code ,contact_detail FROM contact WHERE priority = 1)<br> PIVOT( MAX(contact_detail) FOR (contact_type_code) IN<br>(SELECT DISTINCT contact_type_code FROM contact) );","Option4":"A,B,C","Option5":"A,B","Answer":"<b>E)</b></br>"},
{"Qno":3,"Question":"Consider the following CUSTOMERS table. IT has a total of 100 rows<br><img src='images\\q3.png'/><br>Which of the following queries will yield a random sample of 10 % of the records in this table?<br><b>Choose 2</b>","Option1":"SELECT cust_id,cust_name<br>FROM plch_customers<br>WHERE dbms_random.value <= 0.1;","Option2":"SELECT cust_id, cust_name FROM plch_customers sample block (10);","Option3":"SELECT cust_id,cust_name<br>FROM(</br>SELECT c.* ,<br>row_number() over ( order by dbms_random.value ) rn ,<br>COUNT(*) over () cnt<br>FROM plch_customers c)<br>WHERE rn / cnt <= 0.1;","Option4":"SELECT cust_id, cust_name FROM plch_customers ORDER BY dbms_random.value<br>FETCH FIRST 10 percent rows only;","Option5":"null","Answer":"<b>C & D</b></br>In this table all data fits within one block, so this query has a 10 percent chance of returning all 100 rows and a 90 percent chance of returning no rows at all. But for much larger sets of data, this can be a very efficient method to sample blocks rather than rows.</br>Function dbms_random.value is only evaluated once for the entire query, as it is independent on the actual row. In 10 percent of the calls this returns all 100 rows, in 90 percent of the calls this returns nothing."},
{"Qno":4,"Question":"The length,  breath and width of a package are stored as a varray in a table with the following definition.create type plch_number_arr_type as varray(3) of number<br>Table plch_packages,<br> <img src='images\\q4.png'/><br>Desired Output:<br><img src='images\\q4a.png'/><br>Which of the following queries will yield the desired output?<br><b>Choose2</b>","Option1":"SELECT id, weight, length, width, depth<br>FROM(<br>SELECT p.id ,p.weight ,d.column_value dim ,<br>row_number() over(partition BY p.id order by rownum ) rn<br>FROM plch_packages p ,<br>TABLE(p.dimensions) d) <br>pivot <br>( MAX(dim) FOR rn IN <br>( 1 AS LENGTH , 2 AS width , 3 AS depth ) )<br>ORDER BY id;","Option2":"SELECT p.id ,<br>p.weight ,<br>p.dimensions(1) length ,<br>p.dimensions(2) width ,<br>p.dimensions(3) depth<br>FROM plch_packages p<br>ORDER BY p.id;","Option3":"SELECT p.id ,p.weight ,<br>(SELECT column_value FROM TABLE(p.dimensions) WHERE rownum = 1) LENGTH ,<br>(SELECT column_value FROM TABLE(p.dimensions) WHERE rownum = 2) width ,<br>(SELECT column_value FROM TABLE(p.dimensions) WHERE rownum = 3) depth<br>FROM plch_packages p ORDER BY p.id;","Option4":"CREATE OR REPLACE<br>FUNCTION plch_array_element(arr plch_number_arr_type ,idx pls_integer )<br>RETURN NUMBER AS<br>BEGIN RETURN arr(idx);<br>END plch_array_element;<br>SELECT p.id ,p.weight ,plch_array_element(p.dimensions, 1) LENGTH ,<br>plch_array_element(p.dimensions, 2) width ,<br>plch_array_element(p.dimensions, 3) depth<br>FROM plch_packages p ORDER BY P.ID;","Option5":"null","Answer":"<b>A&D</b><br>Here we unnest the collection using the TABLE operator, then we number the elements using ROW_NUMBER(), and finally we PIVOT to get the desired result.<br>It is only PL/SQL that can read elements in a collection like this. SQL raises exception ORA-00904.Only LENGTH will be correct - width and depth will be NULL as WHERE ROWNUM = {something bigger than 1} will never happen.<br>Choice 1 demonstrated SQL cannot access elements of the collection directly. PL/SQL can do it, however, so we can create a function to extract a given element from a given collectionb.ut this method does have a penalty in a lot of context switching.Using PRAGMA UDF compiles the function in a 'SQL friendly' fashion, which in favorable circumstances can eliminate much of the overhead usually found in context switching between SQL and PL/SQL.Best solution is to use the with clause in the function available in 12c with function array_element<br>(arr plch_number_arr_type<br>,idx pls_integer)<br>return number<br>as<br>   begin<br>      return arr(idx);<br>   end;<br>select p.id<br>     , p.weight<br>    , array_element(p.dimensions, 1) length<br>     , array_element(p.dimensions, 2) width<br>    , array_element(p.dimensions, 3) depth<br>  from plch_packages p<br>order by p.id"},
{"Qno":5,"Question":"Consider the following table<br><img src='images\\q5.png'/><br>Scores with competition_type = 'C' was played as part of the Championship, while competition_type = 'T' are scores from taking the competition afterwards as a Test.In the championship the five players were ranked like this:<br><img src='images\\q5a.png'/><br>Gina, Fred and Hugo would like to know what their rank would be if they had a sixth player in the championship. ie<br><img src='images\\q5b.png'/><br> <b>Choose 2</b>","Option1":"SELECT test.player ,<br>MAX(test.score) score ,<br>rank(MAX(test.score)) within GROUP (<br>ORDER BY champ.score DESC ) hypothetical_rank<br>FROM plch_scores test<br>CROSS JOIN plch_scores champ<br>WHERE test.competition_type = 'T'<br>AND champ.competition_type  = 'C'<br>GROUP BY test.player ORDER BY score DESC ,test.player;","Option2":"SELECT player ,score ,hypothetical_rank<br>FROM (SELECT player ,score ,rank() over (order by score DESC) hypothetical_rank ,<br>competition_type FROM plch_scores )<br>WHERE competition_type = 'T' ORDER BY score DESC , player;","Option3":"SELECT player ,score ,hypothetical_rank FROM<br>(SELECT test.player ,test.score ,<br>rank() over ( partition BY test.player order by champ.score DESC ) hypothetical_rank ,<br>champ.competition_type<br>FROM plch_scores test<br>JOIN plch_scores champ<br>ON champ.competition_type   = 'C'<br>OR champ.player = test.player<br>WHERE test.competition_type = 'T')<br>WHERE competition_type = 'T'<br>ORDER BY score DESC ,player;","Option4":"SELECT test.player ,test.score ,<br>(SELECT rank(test.score) within GROUP (<br>ORDER BY champ.score DESC )<br>FROM plch_scores champ<br>WHERE champ.competition_type = 'C'<br>) hypothetical_rank<br>FROM plch_scores test<br>WHERE test.competition_type = 'T'<br>ORDER BY test.score DESC ,<br>TEST.PLAYER;","Option5":"null","Answer":"<b> C, D</b><br>A) this choice raises ORA-30496: Argument should be a constant.If we try to replace one line of this choice (which obviously will not work):  , rank(test.score) within group (We get a more descriptive exception: ORA-30497: Argument should be a constant or a function of expressions in GROUP BY. It is not allowed to nest the aggregates and do the aggregate RANK on the result of aggregate MAX.<br>B) In this choice we pretend all three Test players played in the championship at the same time and use analytic RANK to calculate the ranks of a hypothetical 8-player championship. Then we filter and just show the three desired players.But the results then show Fred wrongly as rank 5 rather than 4 because Gina is included in the rank calculation above Fred. And Hugo wrongly displays rank 7 because Gina and Fred are included above Hugo.<br><b>C)</b> In this one we join each Test score to itself and all the Championship scores. By partitioning the analytic RANK by the Test player we get that analytic RANK is calculated for three partitions of 6 rows each and we get the desired result.This is just more complex than needed when we instead could use RANK in its aggregate form.<br><b>D)</b> The scalar subquery selects the group of scores from the Championship. Aggregate RANK is then used to calculate hypothetical rank for the Test score. This is repeated for all three Test score"},
{"Qno":6,"Question":"From time to time we need to CREATE VIRTUAL DATA - that is create a row source that generates dummy data (that do not exist in a table) to be used in select statements.Now we have a specific case where we need to generate 10 rows of virtual data having a numeric column named ID with the values 101, 102, 103, 104, 105, 201, 202, 203, 204 and 205.Which of the choices create this desired output: <br><img src='images\\q6.png'/><br><b>Choose 3</b>","Option1":"SELECT CASE<br>WHEN level <= 5<br>THEN 100 + level<br>ELSE 195 + level<br>END id<br>FROM dual<br>CONNECT BY level <= 10<br>ORDER BY id","Option2":"SELECT CASE<br>WHEN rownum <= 5<br>THEN 100 + rownum ELSE 195 + rownum<br>END id<br>FROM dual<br>CONNECT BY rownum <= 10<br>ORDER BY id","Option3":"SELECT rownum id<br>FROM dual<br>WHERE rownum BETWEEN 101 AND 105<br>OR rownum BETWEEN 201 AND 205<br>CONNECT BY rownum <= 205<br>ORDER BY id","Option4":"SELECT level id<br>FROM dual<br>CONNECT BY level BETWEEN 101 AND 105<br>OR level BETWEEN 201 AND 205<br>ORDER BY id","Option5":"SELECT 101 id FROM dual UNION ALL<br>SELECT 102 id FROM dual UNION ALL<br>SELECT 103 id FROM dual UNION ALL<br>SELECT 104 id FROM dual UNION ALL<br>SELECT 105 id FROM dual UNION ALL<br>SELECT 201 id FROM dual UNION ALL<br>SELECT 202 id FROM dual UNION ALL<br>SELECT 203 id FROM dual UNION ALL<br>SELECT 204 id FROM dual UNION ALL<br>SELECT 205 id FROM dual ORDER BY ID","Answer":"<b>A, B, D</b><br>Wrong. Will never reach level 101 so this connect by will never return more than one row with id=1. Wrong. Rownum is incremented as rows are generated, but the where clause makes sure no rows are generated, so the connect by clause is always true (0 <= 205) and this is an infinite loop until we run out of memory and get ORA-30009."}
]

